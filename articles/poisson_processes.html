<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David L Miller">
<meta name="dcterms.date" content="2024-06-13">

<title>Poisson processes in mgcv – Yes! You can do that in `mgcv`!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-cf6166c893c2d932d241f30071efce7e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- thanks to Eli Holmes for this trick! https://github.com/quarto-dev/quarto-cli/issues/2275 -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: {autoNumber: "AMS"} },
  tex2jax: {inlineMath: [ ['$','$'], ["\\(","\\)"] ]}
});
</script>

<!-- This is what works with Quarto -->
<script>
  MathJax = {
    tex: {
      tags: 'ams'  // should be 'ams', 'none', or 'all'
    }
  };
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Yes! You can do that in <code>mgcv</code>!</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contributing.html"> 
<span class="menu-text">Contributing material</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-articles" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Articles</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-articles">    
        <li>
    <a class="dropdown-item" href="../articles/gamvar.html">
 <span class="dropdown-text">GAM variance estimation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/prediction_intervals.html">
 <span class="dropdown-text">Prediction intervals</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/poisson_processes.html">
 <span class="dropdown-text">Poisson processes in <code>mgcv</code></span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/ncv.html">
 <span class="dropdown-text">Neighbourhood cross-validation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/ncv_timeseries.html">
 <span class="dropdown-text">Neighbourhood cross-validation for time series</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#poisson-processes---what-are-they-and-when-might-we-use-them" id="toc-poisson-processes---what-are-they-and-when-might-we-use-them" class="nav-link active" data-scroll-target="#poisson-processes---what-are-they-and-when-might-we-use-them">Poisson processes - what are they, and when might we use them?</a></li>
  <li><a href="#fitting-poisson-processes-in-mgcv" id="toc-fitting-poisson-processes-in-mgcv" class="nav-link" data-scroll-target="#fitting-poisson-processes-in-mgcv">Fitting Poisson processes in <code>mgcv</code></a>
  <ul class="collapse">
  <li><a href="#you-aint-seen-nothin-yet-the-berman-turner-device" id="toc-you-aint-seen-nothin-yet-the-berman-turner-device" class="nav-link" data-scroll-target="#you-aint-seen-nothin-yet-the-berman-turner-device">🎶You ain’t seen nothin’ yet🎶 – the Berman-Turner device</a></li>
  </ul></li>
  <li><a href="#an-example---gorilla-nests" id="toc-an-example---gorilla-nests" class="nav-link" data-scroll-target="#an-example---gorilla-nests">An example - gorilla nests</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements">Acknowledgements</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Poisson processes in <code>mgcv</code></h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David L Miller </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 13, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>This article is based on the (excellent!) paper <span class="citation" data-cites="doversFittingLogGaussianCox2024">Dovers <em>et al.</em> (<a href="#ref-doversFittingLogGaussianCox2024" role="doc-biblioref">2024</a>)</span> (which I reviewed). Go read that paper! This is just a quick note on doing this stuff with a slightly different view on the world.</p>
<p>The general idea here is that we want to fit a model to <em>location</em> data, i.e., <span class="math inline">\((x, y)\)</span> locations in space, where the data we have is just the presences of things we saw. Think: making a map of where trees are based on observations of trees. There are specialized ways of doing this but there’s also a neat trick to do this in any GLM-ish<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> framework that interests you.</p>
<p>On a side note, I did write this stuff aaaages ago and then neglected to put it anywhere (like a journal), so this also a way to get that stuff out there (thanks to Elliot and co, at least I don’t have to deal with a journal now!).</p>
<section id="poisson-processes---what-are-they-and-when-might-we-use-them" class="level1">
<h1>Poisson processes - what are they, and when might we use them?</h1>
<p>Let’s say we have data, which are the locations in space of <em>things we’re interested in</em>: animals, insects, trees, etc. We want to build a spatial model of these locations to describe how their occurrence varies over space. The kind of model we need for this are Poisson processes. There are lots of variations on these kinds of models, the version we’re interested in here are <em>log-Gaussian Cox processes</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<div class="cell" data-fig.caption="Gorillas">
<div class="cell-output-display">
<div id="fig-gorillas" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-gorillas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="poisson_processes_files/figure-html/fig-gorillas-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-gorillas-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Locations of gorilla nests from “a National Park in Cameroon” (Kagwene Gorilla Sanctuary). See <code>?spatstat.data::gorillas</code> and <span class="citation" data-cites="funwi-gabgaUnderstandingNestingSpatial2012">Funwi-Gabga and Mateu (<a href="#ref-funwi-gabgaUnderstandingNestingSpatial2012" role="doc-biblioref">2012</a>)</span> for more information.
</figcaption>
</figure>
</div>
</div>
</div>
<p>More formally, say we have locations of <span class="math inline">\(m\)</span> observed locations (“points”) <span class="math inline">\(\left\{ \mathbf{x}_{i};i=1,\ldots,m\right\}\)</span> in the region <span class="math inline">\(\Omega\)</span> occur according to some intensity function <span class="math inline">\(\lambda(\mathbf{x},\boldsymbol{\theta})\)</span>. The inhomogeneous Poisson process likelihood <span class="citation" data-cites="illian_statistical_2008">(<a href="#ref-illian_statistical_2008" role="doc-biblioref">Illian <em>et al.</em>, 2008</a>, eqn. 3.4.4)</span> for this data is:</p>
<p><span class="math display">\[\begin{equation}
\mathcal{\mathcal{L}}_{\text{PPM}}(\boldsymbol{\theta};\left\{ \mathbf{x}_{i};i=1,\ldots,m\right\} )=\frac{\prod_{i=1}^{m}\lambda(\mathbf{x}_{i},\boldsymbol{\theta})}{\exp\Lambda(\boldsymbol{\theta})}=\frac{\prod_{i=1}^{m}\lambda(\mathbf{x}_{i},\boldsymbol{\theta})}{\exp\int_{\Omega}\lambda(\mathbf{x},\boldsymbol{\theta})\mathnormal{\mathrm{d}}\mathbf{x}},
\label{eq:pp-lik}
\end{equation}\]</span></p>
<p>so the log-likelihood is:</p>
<p><span class="math display">\[\begin{equation}
l_{\text{PPM}}=\log_{e}\mathcal{\mathcal{L}}_{\text{PPM}}(\boldsymbol{\theta};\left\{ \mathbf{x}_{i};i=1,\ldots,m\right\} )=\sum_{i=1}^{m}\log_{e}\lambda(\mathbf{x}_{i},\boldsymbol{\theta})-\int_{\Omega}\lambda(\mathbf{x},\boldsymbol{\theta})\mathnormal{\mathrm{d}}\mathbf{x}.
\label{eq:logppm}
\end{equation}\]</span></p>
<p>We might think about directly optimising this likelihood, but we have another option…</p>
</section>
<section id="fitting-poisson-processes-in-mgcv" class="level1">
<h1>Fitting Poisson processes in <code>mgcv</code></h1>
<p>The central piece in fitting a Poisson process in <code>mgcv</code> is a trick called <em>the Berman-Turner device</em> <span class="citation" data-cites="berman_approximating_1992 baddeley_practical_2000">(<a href="#ref-baddeley_practical_2000" role="doc-biblioref">Baddeley and Turner, 2000</a>; <a href="#ref-berman_approximating_1992" role="doc-biblioref">Berman and Turner, 1992</a>)</span>. This allows us to approximate the likelihood in (<span class="math inline">\(\ref{eq:logppm}\)</span>) as part of a generalized linear model (or similar) fitting procedure. That means that we can write our model in a particular way in standard software.</p>
<p>This is good for a few reasons. One being that we already understand how to fit a GLM/GLMM/GAM – that’s great. Second is that we can borrow the cool stuff that we have in our toolbox from these methods – random effects, splines etc.</p>
<section id="you-aint-seen-nothin-yet-the-berman-turner-device" class="level2">
<h2 class="anchored" data-anchor-id="you-aint-seen-nothin-yet-the-berman-turner-device">🎶You ain’t seen nothin’ yet<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>🎶 – the Berman-Turner device</h2>
<p>We can re-write the integral above as a quadrature approximation, so</p>
<p><span class="math display">\[\begin{equation*}
\Lambda(\boldsymbol{\theta})=\int_{\Omega}\lambda(\mathbf{x},\boldsymbol{\theta})\mathnormal{\mathrm{d}}\mathbf{x}\approx\sum_{j=1}^{J}w_{j}\lambda(\mathbf{s}_{j},\boldsymbol{\theta})
\end{equation*}\]</span></p>
<p>with quadrature evaluations (according to some scheme, see below) at <span class="math inline">\(\mathbf{s}_{j}\)</span> and corresponding weights <span class="math inline">\(w_{j}\)</span>. We can then re-write (<span class="math inline">\(\ref{eq:logppm}\)</span>) as:</p>
<p><span class="math display">\[\begin{equation*}
l_{\text{PPM}}\approx\sum_{i=1}^{m}\log_{e}\lambda(\mathbf{x}_{i},\boldsymbol{\theta})-\sum_{j=1}^{J}w_{j}\lambda(\mathbf{s}_{j},\boldsymbol{\theta}).
\end{equation*}\]</span></p>
<p>Then, concatenating <span class="math inline">\(\mathbf{x}_{i}\)</span> and <span class="math inline">\(\mathbf{s}_{j}\)</span> (i.e., combining the observations and quadrature points) into a new <span class="math inline">\(\mathbf{x}_{i}\)</span>, we can re-write this as <span class="citation" data-cites="berman_approximating_1992">Baddeley and Turner (<a href="#ref-baddeley_practical_2000" role="doc-biblioref">2000</a>)</span>, we can combine the two terms into one index:</p>
<p><span class="math display">\[\begin{equation}
l_{\text{PPM}}\approx\sum_{i=1}^{m+J}y_{i}\log_{e}\lambda(\mathbf{x}_{i},\boldsymbol{\theta})-w_{i}\lambda(\mathbf{x}_{i},\boldsymbol{\theta}),
\label{eq:ppm-approx}
\end{equation}\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{equation*}
y_{i}=\begin{cases}
1 &amp; \text{if }\mathbf{x}_{i} \text{ is an observation},\\
0 &amp; \text{if }\mathbf{x}_{i} \text{ is a quadrature point},
\end{cases}
\end{equation*}\]</span></p>
<p>and extending the <span class="math inline">\(w_{i}\)</span> such that</p>
<p><span class="math display">\[\begin{equation*}
w_{i}=\begin{cases}
1 &amp; \text{for } i=1,\ldots,m,\\
w_{j} &amp; \text{for }i=m+1,\ldots,m+J \text{ and }j=1,\ldots,J.
\end{cases}
\end{equation*}\]</span></p>
<p>This looks very close to the form for a Poisson regression with offset <span class="math inline">\(w_{i}\)</span>, we have a linear predictor of the form <span class="math inline">\(\eta_{i}=\log_{e}w_{i}+\mathbf{x}_{i}\boldsymbol{\theta}\)</span>:</p>
<p><span class="math display">\[\begin{align}
l_{\text{PO}}(\boldsymbol{\beta};\mathbf{x}_{1},\ldots,\mathbf{x}_{n};y_{1},\ldots,y_{n}) &amp;=\sum_{i=1}^{n}\left(y_{i}\eta_{i}-e^{\eta_{i}}-\log_{e}\left(y_{i}!\right)\right)\\
&amp;=\sum_{i=1}^{n}\left(y_{i}(\log_{e}w_{i}+\mathbf{x}_{i}\boldsymbol{\theta})-e^{\log_{e}w_{i}}e^{\mathbf{x}_{i}\boldsymbol{\theta}}-\log_{e}\left(y_{i}!\right)\right)\\
&amp;=\sum_{i=1}^{n}\left(y_{i}(\log_{e}w_{i}+\mathbf{x}_{i}\boldsymbol{\theta})-w_{i}e^{\mathbf{x}_{i}\boldsymbol{\theta}}\right)
\label{eq:poisson-reg}
\end{align}\]</span></p>
<p>Note that since <span class="math inline">\(y_{i}\in\{0,1\}\)</span>, <span class="math inline">\(y_{i}!=1\Rightarrow\log_{e}\left(y_{i}!\right)=0\)</span> hence we lose the last term in the second line. So letting <span class="math inline">\(\lambda(\mathbf{x}_{i},\boldsymbol{\theta})=\exp(\log_{e}w_{i}+\mathbf{x}_{i}\boldsymbol{\theta})\)</span> we have that (<span class="math inline">\(\ref{eq:poisson-reg}\)</span>) is equivalent to (<span class="math inline">\(\ref{eq:ppm-approx}\)</span>). Note that sometimes this derivation is via using weights rather than using the offset. This approach is generally referred to as the “Berman-Turner device”.</p>
<p>So to fit the inhomogeneous Poisson process model in (<span class="math inline">\(\ref{eq:pp-lik}\)</span>), we can fit a Poisson GLM with the following components:</p>
<ul>
<li>response vector <span class="math inline">\(\mathbf{y}=(\overbrace{1,\ldots,1}^{m\text{ times}},\overbrace{0,\ldots,0}^{J\text{ times}})\)</span>,</li>
<li>design matrix <span class="math inline">\(\mathbf{X}\)</span>, where the first <span class="math inline">\(m\)</span> rows are the data locations (and potentially associated covariates), then the following <span class="math inline">\(J\)</span> rows are the locations of the quadrature points,</li>
<li>offset vector of <span class="math inline">\(1\)</span>s and quadrature weights, <span class="math inline">\(\mathbf{w}=(\overbrace{1,\ldots,1}^{m\text{ times}},w_{1},\ldots,w_{J})\)</span>.</li>
</ul>
<p>Generating an efficient and accurate quadrature scheme for the given problem can potentially be tricky. In one dimension generating a mesh for the quadrature is pretty simple, we can just make an evenly-spaced grid over space (or the range of the covariate). In higher dimensions with uneven data this can be more complicated. <span class="citation" data-cites="warton_poisson_2010">Warton and Shepherd (<a href="#ref-warton_poisson_2010" role="doc-biblioref">2010</a>)</span> suggest increasing grid complexity until convergence of the maximum likelihood estimate to ensure that the integral is approximated correctly. <span class="citation" data-cites="simpson_going_2016">Simpson <em>et al.</em> (<a href="#ref-simpson_going_2016" role="doc-biblioref">2016</a>)</span> suggest that regular grids are computationally wasteful and suggest the use of triangulation for efficiency.</p>
</section>
</section>
<section id="an-example---gorilla-nests" class="level1">
<h1>An example - gorilla nests</h1>
<p>If you’ve spent some time in the point process world, you’ve probably seen the gorilla nests example (<span class="citation" data-cites="funwi-gabgaUnderstandingNestingSpatial2012">Funwi-Gabga and Mateu (<a href="#ref-funwi-gabgaUnderstandingNestingSpatial2012" role="doc-biblioref">2012</a>)</span> gives more information about the data). We can start by producing <a href="#fig-gorillas" class="quarto-xref">Figure&nbsp;1</a> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fmesher)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(spatstat.data)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># set up the data</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(gorillas,<span class="at">package=</span><span class="st">"spatstat.data"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x=</span>gorillas<span class="sc">$</span>x, <span class="at">y=</span>gorillas<span class="sc">$</span>y)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># just grab the dry season data for simplicity</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> dat[gorillas<span class="sc">$</span>marks<span class="sc">$</span>season<span class="sc">==</span><span class="st">"dry"</span>, ]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># plot that</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dat, <span class="fu">aes</span>(<span class="at">x=</span>x,<span class="at">y=</span>y)) <span class="sc">+</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_equal</span>() <span class="sc">+</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first step we need to undertake is to construct the mesh. Here we follow the Simpson approach and use a mesh (triangulation) provided by <code>fmesher</code><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> as the integration scheme for our model. In particular we can use <code>fmesher::meshbuilder()</code> (a Shiny app) to graphically set up and assess the utility of a mesh for a given dataset.</p>
<p>Fortunately as this is a <code>spatstat</code> dataset, we already have a <code>$window$bdry</code> that gives the boundary polygon we want to use (note that these polygons don’t have the same first/last elements, so they don’t plot as a closed loop). If we didn’t have that we could use an <code>sf</code> function like <a href="https://r-spatial.github.io/sf/reference/geos_unary.html"><code>st_convex_hull</code></a> to construct a convex hull around our points, then perhaps <code>st_buffer</code> to make a slightly larger area.</p>
<p>We can feed this polygon to the <code>fm_segm()</code> function in <code>fmesher</code> to generate a boundary that <code>fmesher</code> understands, then use <code>fm_mesh_2d</code> to generate the mesh.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(gorillas<span class="sc">$</span>window<span class="sc">$</span>bdry[[<span class="dv">1</span>]], <span class="at">type=</span><span class="st">"l"</span>, <span class="at">asp=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="poisson_processes_files/figure-html/mesh-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># mesh code provided by David Borchers</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>bnd <span class="ot">&lt;-</span> <span class="fu">fm_segm</span>(<span class="at">loc =</span> <span class="fu">data.frame</span>(gorillas<span class="sc">$</span>window<span class="sc">$</span>bdry[[<span class="dv">1</span>]]))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>mesh <span class="ot">&lt;-</span> <span class="fu">fm_mesh_2d</span>(<span class="at">interior =</span> bnd, <span class="at">max.edge =</span> <span class="dv">300</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s take a look at the mesh…</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(mesh)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-mesh" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mesh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="poisson_processes_files/figure-html/fig-mesh-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mesh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Triangulation that we’ll use for the gorilla nest example. The blue line gives the boundary we supplied.
</figcaption>
</figure>
</div>
</div>
</div>
<p>With the mesh setup, we need to work out the centroids and areas of the triangles. We can do this using some stored information in the mesh object and some basic maths. I’ve written this into the <code>get_grid</code> function below for ease of use later on.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>get_grid <span class="ot">&lt;-</span> <span class="cf">function</span>(mesh){</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># get the finite elements</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  fem <span class="ot">&lt;-</span> <span class="fu">fm_fem</span>(mesh, <span class="at">order =</span> <span class="dv">1</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># areas</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  w <span class="ot">&lt;-</span> fem<span class="sc">$</span>ta</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># get the centroids of the triangles</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  mesh_locs <span class="ot">&lt;-</span> mesh<span class="sc">$</span>loc[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  idx <span class="ot">&lt;-</span> mesh<span class="sc">$</span>graph<span class="sc">$</span>tv</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  tri_loc <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">t</span>(<span class="fu">apply</span>(idx, <span class="dv">1</span>, <span class="cf">function</span>(ii){</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span><span class="sc">/</span><span class="dv">3</span><span class="sc">*</span><span class="fu">colSums</span>(mesh_locs[ii,])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  })))</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  dat <span class="ot">&lt;-</span> <span class="fu">cbind</span>(tri_loc, w)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">names</span>(dat) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>, <span class="st">"area"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(dat)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co"># get triangle locations and sizes from the mesh</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>tri <span class="ot">&lt;-</span> <span class="fu">get_grid</span>(mesh)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>tri</code> is a 3 column matrix with location in the first 2 columns and area in the final one:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(tri)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         x        y     area
1 581857.3 678547.6 30298.15
2 585036.4 675553.8 17351.60
3 582956.8 678882.9 24491.24
4 582096.7 674272.4 18901.22
5 581981.2 675168.1 14841.59
6 581755.2 674451.9 21700.33</code></pre>
</div>
</div>
<p>Now we have our data and our integration grid<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, we can think about getting the <code>data.frame</code> together that we need for modelling.</p>
<p>From the above we need the following columns in our data:</p>
<ul>
<li>locations (<code>x</code> and <code>y</code>)</li>
<li>weights (<code>area</code>)</li>
<li>0/1 response (<code>presence</code>)</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># add area column to the data</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># this is just a small value</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>area <span class="ot">&lt;-</span> <span class="fl">1e-6</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># response data</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>presence <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>tri<span class="sc">$</span>presence <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># bind these two together</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>ppm_dat <span class="ot">&lt;-</span> <span class="fu">rbind</span>(dat, tri)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># need the log area</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>ppm_dat<span class="sc">$</span>larea <span class="ot">&lt;-</span> <span class="fu">log</span>(ppm_dat<span class="sc">$</span>area)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co"># what does that look like</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(ppm_dat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         x        y  area presence     larea
1 582518.4 676886.2 1e-06        1 -13.81551
2 581823.0 677422.7 1e-06        1 -13.81551
3 582131.0 676937.9 1e-06        1 -13.81551
4 582111.9 677420.0 1e-06        1 -13.81551
5 582585.1 677509.7 1e-06        1 -13.81551
6 582302.3 677521.6 1e-06        1 -13.81551</code></pre>
</div>
</div>
<p>Now we can fit the model, using the usual <code>gam</code> apparatus:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mgcv)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: nlme</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>This is mgcv 1.9-3. For overview type 'help("mgcv-package")'.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>pp <span class="ot">&lt;-</span> <span class="fu">gam</span>(presence <span class="sc">~</span> <span class="fu">offset</span>(larea) <span class="sc">+</span> <span class="fu">s</span>(x, y, <span class="at">bs=</span><span class="st">"tp"</span>, <span class="at">k=</span><span class="dv">40</span>),</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>          <span class="at">data=</span>ppm_dat, <span class="at">method=</span><span class="st">"REML"</span>, <span class="at">family=</span><span class="fu">poisson</span>())</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(pp)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Family: poisson 
Link function: log 

Formula:
presence ~ offset(larea) + s(x, y, bs = "tp", k = 40)

Parametric coefficients:
            Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)  -17.689      2.304  -7.676 1.64e-14 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Approximate significance of smooth terms:
         edf Ref.df Chi.sq p-value    
s(x,y) 19.29  22.06  237.3  &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

R-sq.(adj) =  -2.11   Deviance explained =  7.6%
-REML = 6751.7  Scale est. = 1         n = 1824</code></pre>
</div>
</div>
<p>Note that we can do things like assess the value we gave <code>k</code> (the maximum basis size) but things like the adjusted-<span class="math inline">\(R^2\)</span> won’t make sense. Also note that you can’t do model comparison (via REML score, AIC etc) between mesh configurations as you’re changing the data in that case.</p>
<p>We can now make a prediction. Before we do that, it’s important to think about what the prediction means. If we just use <code>predict()</code> on our model, then we are getting values of the <span class="math inline">\(\log\)</span> intensity, <span class="math inline">\(\log_e \lambda(x,y)\)</span> for whatever <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> we supply. Exponentiating gives us the intensity, but what does that <strong>mean</strong>? Something like “<span class="math inline">\(\lambda (x,y) \mathrm {d} x\mathrm {d}y\)</span> is the infinitesimal probability of a point of a Poisson point process existing in a region of space with volume <span class="math inline">\(\mathrm {d} x\mathrm {d}y\)</span> located at <span class="math inline">\((x, y)\)</span>”<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. So we can use <span class="math inline">\(\lambda (x,y) a\)</span> to give a probability, if we let <span class="math inline">\(a\)</span> be the area we’re interested in around <span class="math inline">\((x,y)\)</span>.</p>
<p>So let’s setup a grid to predict over and make the prediction:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># make a prediction</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># set up the prediction grid</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>npred <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">x =</span> <span class="fu">seq</span>(<span class="fu">min</span>(dat<span class="sc">$</span>x), <span class="fu">max</span>(dat<span class="sc">$</span>x), <span class="at">len=</span>npred),</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                    <span class="at">y =</span> <span class="fu">seq</span>(<span class="fu">min</span>(dat<span class="sc">$</span>y), <span class="fu">max</span>(dat<span class="sc">$</span>y), <span class="at">len=</span>npred))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"># areas</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>pred<span class="sc">$</span>larea <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fu">diff</span>(pred<span class="sc">$</span>x)[<span class="dv">1</span>] <span class="sc">*</span> <span class="fu">diff</span>(pred<span class="sc">$</span>y)[npred])</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co"># make the prediction</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>pred<span class="sc">$</span>p <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="fu">predict</span>(pp, pred))</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co"># range of values</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="fu">range</span>(pred<span class="sc">$</span>p)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3.643101e-07 1.567722e-01</code></pre>
</div>
</div>
<p>Finally we can plot that using <code>ggplot2</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(pred, <span class="fu">aes</span>(<span class="at">x=</span>x,<span class="at">y=</span>y)) <span class="sc">+</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>(<span class="fu">aes</span>(<span class="at">fill=</span>p)) <span class="sc">+</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data=</span>dat) <span class="sc">+</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_fill_viridis_c</span>() <span class="sc">+</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">fill=</span><span class="st">"Gorilla</span><span class="sc">\n</span><span class="st">occurrance</span><span class="sc">\n</span><span class="st">probability"</span>) <span class="sc">+</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_equal</span>() <span class="sc">+</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="poisson_processes_files/figure-html/plot-res-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p>So this stuff is quite basic compared to what’s going on in the Poisson process literature at the moment, but hopefully it gives some ideas of where we could go and again shows that we can use <code>mgcv</code> for more than we expected.</p>
<p>The above starts to make <code>mgcv</code> suspiciously like <a href="http://inlabru.org/"><code>inlabru</code></a>: we fit a <span class="math inline">\(\log\)</span>-Gaussian Cox process, using a triangulation and smoothing, with empirical Bayesian methods. We could use a Mat{'e}rn covariance approach via a stochastic partial differential equation method in <code>mgcv</code> using methods in <span class="citation" data-cites="millerUnderstandingStochasticPartial2019">Miller <em>et al.</em> (<a href="#ref-millerUnderstandingStochasticPartial2019" role="doc-biblioref">2019</a>)</span>.</p>
<p>Note that importantly, a simple Poisson process (LGCP) will not work (in a very theory-centric sense) if you have repeated measures at the same locations. For example if you had fisheries data where you go to exactly the same trawl locations. This has something to do with the probability of two observations being at the same point in space being zero<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
</section>
<section id="acknowledgements" class="level1">
<h1>Acknowledgements</h1>
<p>My original work in this area was heavily influenced by discussions with Finn Lindgren and Andy Seaton. David Borchers provided the mesh parameters. Thanks also to Philip Dixon for asking me to review the paper!</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-baddeley_practical_2000" class="csl-entry" role="listitem">
Baddeley, A. and Turner, R. (2000) Practical <span>Maximum Pseudolikelihood</span> for <span>Spatial Point Patterns</span>. <em>Australian &amp; New Zealand Journal of Statistics</em>, <strong>42</strong>, 283–322.
</div>
<div id="ref-berman_approximating_1992" class="csl-entry" role="listitem">
Berman, M. and Turner, T. R. (1992) Approximating <span>Point Process Likelihoods</span> with <span>GLIM</span>. <em>Applied Statistics</em>, <strong>41</strong>, 31. DOI: <a href="https://doi.org/10.2307/2347614">10.2307/2347614</a>.
</div>
<div id="ref-doversFittingLogGaussianCox2024" class="csl-entry" role="listitem">
Dovers, E., Stoklosa, J. and Warton, D. I. (2024) Fitting log-<span>Gaussian Cox</span> processes using generalized additive model software. <em>The American Statistician</em>, 1–17. DOI: <a href="https://doi.org/10.1080/00031305.2024.2316725">10.1080/00031305.2024.2316725</a>.
</div>
<div id="ref-funwi-gabgaUnderstandingNestingSpatial2012" class="csl-entry" role="listitem">
Funwi-Gabga, N. and Mateu, J. (2012) Understanding the nesting spatial behaviour of gorillas in the <span>Kagwene Sanctuary</span>, <span>Cameroon</span>. <em>Stochastic Environmental Research and Risk Assessment</em>, <strong>26</strong>, 793–811. DOI: <a href="https://doi.org/10.1007/s00477-011-0541-1">10.1007/s00477-011-0541-1</a>.
</div>
<div id="ref-illian_statistical_2008" class="csl-entry" role="listitem">
Illian, J., Penttinen, P. A., Stoyan, H., et al. (2008) <em>Statistical <span>Analysis</span> and <span>Modelling</span> of <span>Spatial Point Patterns</span></em>. Statistics in <span>Practice</span>. <span>Wiley</span>.
</div>
<div id="ref-millerUnderstandingStochasticPartial2019" class="csl-entry" role="listitem">
Miller, D. L., Glennie, R. and Seaton, A. E. (2019) Understanding the <span>Stochastic Partial Differential Equation Approach</span> to <span>Smoothing</span>. <em>Journal of Agricultural, Biological and Environmental Statistics</em>. DOI: <a href="https://doi.org/10.1007/s13253-019-00377-z">10.1007/s13253-019-00377-z</a>.
</div>
<div id="ref-simpson_going_2016" class="csl-entry" role="listitem">
Simpson, D., Illian, J. B., Lindgren, F., et al. (2016) Going off grid: Computationally efficient inference for log-<span>Gaussian Cox</span> processes. <em>Biometrika</em>, <strong>103</strong>, 49–70. DOI: <a href="https://doi.org/10.1093/biomet/asv064">10.1093/biomet/asv064</a>.
</div>
<div id="ref-warton_poisson_2010" class="csl-entry" role="listitem">
Warton, D. I. and Shepherd, L. C. (2010) Poisson point process models solve the <span>“pseudo-absence problem”</span> for presence-only data in ecology. <em>The Annals of Applied Statistics</em>, <strong>4</strong>, 1383–1402. DOI: <a href="https://doi.org/10.1214/10-AOAS331">10.1214/10-AOAS331</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Generalized linear model, generalized linear mixed model and <em>of course</em> generalized additive model.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>That is, where we describe the variation in space using structured random effects that are (multivariate) normal distributed.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>See <a href="https://www.youtube.com/watch?v=4cia_v4vxfE">https://www.youtube.com/watch?v=4cia_v4vxfE</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Written by Finn Lindgren and available <a href="https://cran.r-project.org/web/packages/fmesher/index.html">on CRAN</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>I’m using “integration grid” and “mesh” interchangably here.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Adapted from <a href="https://en.wikipedia.org/wiki/Poisson_point_process#Interpretation_of_the_intensity_function">here</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>A property of being something called a <em>simple point process</em>. Janine Illian once tried to explain this to me but I’ve forgotten now. Sorry Janine!<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/calgary\.converged\.yt");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>