<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.52">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David L Miller">
<meta name="dcterms.date" content="2024-07-01">

<title>Neighbourhood cross-validation – Yes! You can do that in mgcv!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- thanks to Eli Holmes for this trick! https://github.com/quarto-dev/quarto-cli/issues/2275 -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: {autoNumber: "AMS"} },
  tex2jax: {inlineMath: [ ['$','$'], ["\\(","\\)"] ]}
});
</script>

<!-- This is what works with Quarto -->
<script>
  MathJax = {
    tex: {
      tags: 'ams'  // should be 'ams', 'none', or 'all'
    }
  };
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Yes! You can do that in <code>mgcv</code>!</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contributing.html"> 
<span class="menu-text">Contributing material</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-articles" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Articles</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-articles">    
        <li>
    <a class="dropdown-item" href="../articles/gamvar.html">
 <span class="dropdown-text">GAM variance estimation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/prediction_intervals.html">
 <span class="dropdown-text">Prediction intervals</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/poisson_processes.html">
 <span class="dropdown-text">Poisson processes in <code>mgcv</code></span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/ncv.html">
 <span class="dropdown-text">Neighbourhood cross-validation</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#cross-validation---what-is-it" id="toc-cross-validation---what-is-it" class="nav-link active" data-scroll-target="#cross-validation---what-is-it">Cross-validation - what is it?</a></li>
  <li><a href="#neighbourhood-cross-validation" id="toc-neighbourhood-cross-validation" class="nav-link" data-scroll-target="#neighbourhood-cross-validation">Neighbourhood cross-validation</a></li>
  <li><a href="#a-simple-example-using-neighbourhood-cross-validation" id="toc-a-simple-example-using-neighbourhood-cross-validation" class="nav-link" data-scroll-target="#a-simple-example-using-neighbourhood-cross-validation">A simple example using neighbourhood cross-validation</a>
  <ul class="collapse">
  <li><a href="#setting-up-a-neighbourhood-structure" id="toc-setting-up-a-neighbourhood-structure" class="nav-link" data-scroll-target="#setting-up-a-neighbourhood-structure">Setting-up a neighbourhood structure</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Neighbourhood cross-validation</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David L Miller </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 1, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>This article is designed as a gentle introduction to the neighbourhood cross-validation fitting method available in <code>mgcv</code> version <a href="https://cran.r-project.org/web/packages/mgcv/ChangeLog">1.9-0</a> onwards. Here I’ll focus on the theory of how this stuff works and I’ll try to write some further articles on the practical side of implementing this in particular situations for those interested in that kind of thing.</p>
<p>The primary reference for this is Simon Wood’s <a href="https://arxiv.org/html/2404.16490v1">arXiv preprint</a>, along with some discussions with Simon and others about various stuff. Thanks to those who listened to me yakk-on about this.</p>
<section id="cross-validation---what-is-it" class="level1">
<h1>Cross-validation - what is it?</h1>
<p>When we fit statistical models, we generally need to know what the performance of our model would be outwith the data we fitted it to. We want to know that the model is not overfitting to the data and that it has some ability to predict “out-of-sample.” This can be tackled as a post-hoc calculation (holding back some subset of the data when fitting the model and then comparing predictions to the real values in the data), or it can be part of the model fitting procedure.</p>
<p>We could think of a simple case where we have <span class="math inline">\(n\)</span> data, we take each of those data in turn and leave it out of the dataset, fitting to the remaining <span class="math inline">\(n-1\)</span> data, then predicting back to that one remaining datum (this is <em>leave-one-out</em> cross-validation, or “LOO”). The idea being that model parameters that are good for all of these subsets are a better, more general fit than if we’d fitted to the whole dataset together.</p>
<p>There are a couple of issues with this in practice:</p>
<ol type="1">
<li>If we have a very large dataset, a naive implementation of the above means that we are fitting <span class="math inline">\(n\)</span> models, so when <span class="math inline">\(n\)</span> is large, this is computationally expensive.</li>
<li>If we have data that are spatial or temporal in nature, then we probably have some autocorrelation in the data. We might then reasonably think that using LOO we have an issue where the non-independence in the data mean that dropping a single datum actually makes little difference (the surrounding data “make-up” for the missing one).</li>
</ol>
<p>Various adaptations have been made to deal with these situations. To combat computational issues, folks use <span class="math inline">\(k\)</span>-fold cross-validation where the <span class="math inline">\(n\)</span> data are separated into <span class="math inline">\(k\)</span> partitions, each one of which is systematically dropped and predicted, in the same way that individual data are for the LOO case. There are also approximations to LOO, like generalized cross-validation<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> (GCV), which is the default method used in <code>mgcv</code>. Instead of refitting many times, we can use the GCV criterion to optimize: <span class="math display">\[
\mathcal{V}_\text{GCV} = \frac{\vert\vert \mathbf{W}^{1/2} \{ \mathbf{y} - \mathbf{Ay}\}  \vert\vert^2 }{1-\text{tr}(A)/n^2}
\]</span> where <span class="math inline">\(\mathbf{y}\)</span> are the response data, <span class="math inline">\(\mathbf{A}\)</span> is the hat matrix<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, <span class="math inline">\(\text{tr}(\mathbf{A})\)</span> is the trace<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> of the matrix <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{W}\)</span> are iterative weights calculated during fitting<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Using <span class="math inline">\(\mathcal{V}_\text{GCV}\)</span> is useful because we can find it’s derivatives and use those during the optimisation procedures when fitting the model. This is the criteria which is optimized when we use <code>method="GCV.Cp"</code> in our call to <code>gam()</code>.</p>
<p>Even using the above “tricks”<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, we still face the second issue of autocorrelation. This can be addressed by selecting the points that go into the partitions to take into account structure in the data. For example, splitting a study area into blocks geographically, dropping each and fitting to the remaining bocks might be an appropriate strategy for spatial data. <span class="citation" data-cites="roberts_cross-validation_2017">Roberts <em>et al.</em> (<a href="#ref-roberts_cross-validation_2017" role="doc-biblioref">2017</a>)</span> show some useful strategies for cross-validation for common situations in ecological modelling.</p>
<p>Another advantage of the cross-validation approach is that parallelisation is fairly straight-forward: you need to fit a series of models that don’t interact with each other, so you can run them on different cores/processors/machines.</p>
</section>
<section id="neighbourhood-cross-validation" class="level1">
<h1>Neighbourhood cross-validation</h1>
<p>To extend these ideas a little further: what if we could do a quick version of cross-validation (using some approximation, say) but for arbitrary blocking schemes, which we can use to account for the autocorrelation issues described above.</p>
<p>The new <code>method="NCV"</code> <span class="citation" data-cites="wood2024neighbourhoodcrossvalidation">(<a href="#ref-wood2024neighbourhoodcrossvalidation" role="doc-biblioref">Wood, 2024</a>)</span> option in <code>mgcv</code> implements a smart version of cross-validation that allows one to specify a set of arbitrary “neighbourhoods” to perform fitting and predicting on. While doing this fitting, we are able to calculate derivatives of the score function we’re using, so we can know which direction to move our parameters. What results is a fast, easily parallelisable, flexible fitting method which can be used to account for autocorrelation in the data without having to fit a separate correlation structure via, say, an autoregressive process in <code>gamm</code> or somesuch.</p>
<p>The idea is relatively simple: define your neighbourhoods, fit to each ensuring that parameters are best for all the neighbourhoods.</p>
<p>It’s worth noting at this point that like the other methods used to “fit a GAM”, what we’re really talking about here is a criterion for estimating smoothing parameters (hyperparameters). As is the case with other methods, we rely on regular GLM-fitting <em>conditional on</em> the smoothing parameters, so we need to get those smoothing parameters reliably for everything to work<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>So, we setup the criterion, which we can write as: <span class="math display">\[
\mathcal{V}_\text{NCV} = \sum_{k=1}^m \sum_{i \in \delta(k)} \mathcal{D}(y_i, \mathbf{\theta}_i^{-\alpha(k)})
\]</span> where we first let <span class="math inline">\(\alpha(k)\)</span> be the <span class="math inline">\(k^\text{th}\)</span> subset of data to drop and <span class="math inline">\(\delta(k)\)</span> be the corresponding <span class="math inline">\(k^\text{th}\)</span> subset to predict. So <span class="math inline">\(\mathcal{D}(y_i, \mathbf{\theta}_i^{-\alpha(k)})\)</span> gives the likelihood<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> for parameter estimates with the subset <span class="math inline">\(\alpha(k)\)</span> missing. We do this for <span class="math inline">\(k=1, \ldots, m\)</span> subsets of the data.</p>
<p>To make the above concrete, we can think about some common cases:</p>
<ul>
<li>LOO: in that case <span class="math inline">\(m=n\)</span> and <span class="math inline">\(\alpha(k)=\delta(k)=k\)</span> – we drop each datum in turn and use the fitted model to predict that datum.</li>
<li><span class="math inline">\(k\)</span>-fold cross-validation: <span class="math inline">\(\alpha(k)=\delta(k)\)</span> but <span class="math inline">\(\alpha(k)\)</span> are each non-overlapping subsets of the data.</li>
</ul>
<p>One of the contributions in the paper is how to calculate derivatives of <span class="math inline">\(\mathcal{V}_\text{NCV}\)</span> so that we can use the technique effectively in <code>mgcv</code>. I’ll not duplicate those details here.</p>
</section>
<section id="a-simple-example-using-neighbourhood-cross-validation" class="level1">
<h1>A simple example using neighbourhood cross-validation</h1>
<p>Let’s have a go at using NCV. First loading <code>mgcv</code> and generating some data to play with:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mgcv)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: nlme</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># generate our fave data</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">gamSim</span>(<span class="dv">1</span>,<span class="at">n=</span><span class="dv">400</span>,<span class="at">dist=</span><span class="st">"normal"</span>,<span class="at">scale=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Gu &amp; Wahba 4 term additive model</code></pre>
</div>
</div>
<p>The default option if we set <code>method="NCV"</code> and if we don’t include a neighbourhood via the <code>nei=</code> argument, is leave-one-out (LOO) cross-validation. We can do this as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">gam</span>(y<span class="sc">~</span><span class="fu">s</span>(x0)<span class="sc">+</span><span class="fu">s</span>(x1)<span class="sc">+</span><span class="fu">s</span>(x2)<span class="sc">+</span><span class="fu">s</span>(x3),<span class="at">data=</span>dat, <span class="at">method=</span><span class="st">"NCV"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Family: gaussian 
Link function: identity 

Formula:
y ~ s(x0) + s(x1) + s(x2) + s(x3)

Parametric coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)   7.8333     0.1005   77.95   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Approximate significance of smooth terms:
        edf Ref.df      F  p-value    
s(x0) 2.484  3.096  6.533 0.000229 ***
s(x1) 2.438  3.029 83.167  &lt; 2e-16 ***
s(x2) 7.701  8.567 94.181  &lt; 2e-16 ***
s(x3) 1.000  1.000  3.588 0.058963 .  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

R-sq.(adj) =  0.715   Deviance explained = 72.5%
NCV = 1618.9  Scale est. = 3.9025    n = 400</code></pre>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(b, <span class="at">pages=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="ncv_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
<p>Note that this is <em>fast</em> and the fits look good.</p>
<section id="setting-up-a-neighbourhood-structure" class="level2">
<h2 class="anchored" data-anchor-id="setting-up-a-neighbourhood-structure">Setting-up a neighbourhood structure</h2>
<p>Let’s define a goofy neighbourhood structure, where we just have four bits, in the order of one of the covariates.</p>
<p>Begin with the <code>list</code> we need to store everything:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>nb <span class="ot">&lt;-</span> <span class="fu">list</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This object will contain our <span class="math inline">\(\alpha(k)\)</span> and <span class="math inline">\(\delta(k)\)</span> information (albeit in a slightly convoluted way).</p>
<p>The leave-outs (<span class="math inline">\(\alpha(k)\)</span>’s) are in the <code>k</code> element of the list. This is a vector of data indices in such an order that each of our cross-validation blocks is contiguous. If our first block is size <code>b</code> then we can get the block indices via <code>k[1]:k[b]</code>.</p>
<p>In our case we want the variable <code>x0</code> chopped into 4 equal-sized, contiguous blocks of length 100. We can do this by getting the order of <code>x0</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>nb<span class="sc">$</span>k <span class="ot">&lt;-</span> <span class="fu">order</span>(dat<span class="sc">$</span>x0)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next we need to set the <em>end points</em> of the blocks in the element <code>m</code>, which in our case will be 100, 200, 300 and 400:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>nb<span class="sc">$</span>m <span class="ot">&lt;-</span> (<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)<span class="sc">*</span><span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For the predictions (<span class="math inline">\(\delta(k)\)</span>’s) we have a similar structure, <code>k</code> is now <code>i</code> and <code>m</code> is now <code>mi</code> (these should be the same length).</p>
<p>Here let’s try to predict only at the points we dropped each time. In that case <code>i == k</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>nb<span class="sc">$</span>i <span class="ot">&lt;-</span> nb<span class="sc">$</span>k</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and <code>mi == m</code></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>nb<span class="sc">$</span>mi <span class="ot">&lt;-</span> nb<span class="sc">$</span>m</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now try to fit that by supplying <code>nb</code> as the <code>nei=</code> argument:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>b2 <span class="ot">&lt;-</span> <span class="fu">gam</span>(y<span class="sc">~</span><span class="fu">s</span>(x0)<span class="sc">+</span><span class="fu">s</span>(x1)<span class="sc">+</span><span class="fu">s</span>(x2)<span class="sc">+</span><span class="fu">s</span>(x3),<span class="at">data=</span>dat, <span class="at">method=</span><span class="st">"NCV"</span>, <span class="at">nei=</span>nb)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(b2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Family: gaussian 
Link function: identity 

Formula:
y ~ s(x0) + s(x1) + s(x2) + s(x3)

Parametric coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  7.83328    0.09885   79.24   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Approximate significance of smooth terms:
        edf Ref.df      F p-value    
s(x0) 3.894  4.802  5.263 0.00017 ***
s(x1) 2.389  2.968 82.370 &lt; 2e-16 ***
s(x2) 7.466  8.416 88.319 &lt; 2e-16 ***
s(x3) 1.000  1.000  4.386 0.03689 *  
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

R-sq.(adj) =  0.715   Deviance explained = 72.5%
NCV = 1635.4  Scale est. = 3.9089    n = 400</code></pre>
</div>
</div>
<p>Note that the NCV score has changed (of course).</p>
<p>Let’s plot that but showing the groupings in the rug plot, colour-coded:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>blerg <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="cf">function</span>(x){</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(b2, <span class="at">select=</span>x, <span class="at">rug=</span><span class="cn">FALSE</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rug</span>(dat[[<span class="fu">paste0</span>(<span class="st">"x"</span>, x<span class="dv">-1</span>)]][nb<span class="sc">$</span>k[<span class="dv">1</span><span class="sc">:</span>nb<span class="sc">$</span>m[<span class="dv">1</span>]]], <span class="at">col=</span><span class="st">"red"</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rug</span>(dat[[<span class="fu">paste0</span>(<span class="st">"x"</span>, x<span class="dv">-1</span>)]][nb<span class="sc">$</span>k[(nb<span class="sc">$</span>m[<span class="dv">1</span>]<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>nb<span class="sc">$</span>m[<span class="dv">2</span>]]], <span class="at">col=</span><span class="st">"green"</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rug</span>(dat[[<span class="fu">paste0</span>(<span class="st">"x"</span>, x<span class="dv">-1</span>)]][nb<span class="sc">$</span>k[(nb<span class="sc">$</span>m[<span class="dv">2</span>]<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>nb<span class="sc">$</span>m[<span class="dv">3</span>]]], <span class="at">col=</span><span class="st">"blue"</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rug</span>(dat[[<span class="fu">paste0</span>(<span class="st">"x"</span>, x<span class="dv">-1</span>)]][nb<span class="sc">$</span>k[(nb<span class="sc">$</span>m[<span class="dv">3</span>]<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>nb<span class="sc">$</span>m[<span class="dv">4</span>]]], <span class="at">col=</span><span class="st">"pink"</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="ncv_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
<p>Performance here is probably good because of the jumbled nature of the other covariates in the model ensuring good fit.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Neighbourhood cross-validation seems like a very promising method for fitting GAMs. Some advantages:</p>
<ul>
<li>Very general: we can write whatever neighbourhood structure we like and use that to fit the model.</li>
<li>Simple to speed-up via parallelisation: making REML/ML work in parallel is fiddly, NCV allows us to parallelise without that faff.</li>
<li>No issues with fixed effects comparison: you can’t compare REML scores between models with different fixed effects structures, this is not a limitation of NCV.</li>
<li>Autocorrelation without additional modelling: we don’t have to fit some AR process to get our autocorrelation accounted for. The caveat here is that we can only do this in the cases where autocorrelation is on a separate scale to the model components – i.e., that we can write our subsets <span class="math inline">\(\alpha(k)\)</span> and <span class="math inline">\(\delta(k)\)</span> such that we can still get our model parameter estimates but that the structure breaks the autocorrelation.</li>
</ul>
<p>So, give it a go. I’ll try to post further examples here as I get to them.</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-reiss_smoothing_2009" class="csl-entry" role="listitem">
Reiss, P. T. and Ogden, T. R. (2009) Smoothing parameter selection for a class of semiparametric linear models. <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, <strong>71</strong>, 505–523.
</div>
<div id="ref-roberts_cross-validation_2017" class="csl-entry" role="listitem">
Roberts, D. R., Bahn, V., Ciuti, S., et al. (2017) Cross-validation strategies for data with temporal, spatial, hierarchical, or phylogenetic structure. <em>Ecography</em>, <strong>40</strong>, 913–929. DOI: <a href="https://doi.org/10.1111/ecog.02881">10.1111/ecog.02881</a>.
</div>
<div id="ref-stone_asymptotic_1977" class="csl-entry" role="listitem">
Stone, M. (1977) An asymptotic equivalence of choice of model by cross-validation and <span>Akaike</span>’s criterion. <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, 44–47.
</div>
<div id="ref-wood2024neighbourhoodcrossvalidation" class="csl-entry" role="listitem">
Wood, S. N. (2024) On neighbourhood cross validation. Available at: <a href="https://arxiv.org/abs/2404.16490">https://arxiv.org/abs/2404.16490</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Which is equivalent to AIC and Mallow’s <span class="math inline">\(C_p\)</span>, see <span class="citation" data-cites="stone_asymptotic_1977">Stone (<a href="#ref-stone_asymptotic_1977" role="doc-biblioref">1977</a>)</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Also called the <a href="https://en.wikipedia.org/wiki/Projection_matrix">projection matrix</a> or influence matrix. I like hat matrix, because it’s what puts the hats on the predictions – it’s the matrix that maps the data <span class="math inline">\(\mathbf{y}\)</span>, say, to it’s predictions <span class="math inline">\(\hat{\mathbf{y}}\)</span>, so <span class="math inline">\(\hat{\mathbf{y}} = A\mathbf{y}\)</span>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Sum of diagonal elements: <span class="math inline">\(\sum_j A_{jj}\)</span> or in R <code>sum(diag(A))</code>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>I’ll write something about P-IRLS and all this stuff at some point.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Note that there’s still a major issue with methods like GCV (“prediction error based methods”, as opposed to likelihood-based methods like REML): they tend to be more sensitive to underfitting, so models end up more smooth than they should. See, e.g., <span class="citation" data-cites="reiss_smoothing_2009">Reiss and Ogden (<a href="#ref-reiss_smoothing_2009" role="doc-biblioref">2009</a>)</span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Things are a bit more complicated than this, but this is the basic idea. I will hopefully at some point write something about that.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>More generally, this can be the loss function for the problem, so we can address a broader set of models, including e.g., quantile regression.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/calgary\.converged\.yt");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>