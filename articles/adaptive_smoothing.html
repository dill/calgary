<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David L Miller">

<title>Adaptive smoothing in mgcv – Yes! You can do that in `mgcv`!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a98ec624fb63d9b712fc3a6f62e2b305.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<!-- thanks to Eli Holmes for this trick! https://github.com/quarto-dev/quarto-cli/issues/2275 -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: {autoNumber: "AMS"} },
  tex2jax: {inlineMath: [ ['$','$'], ["\\(","\\)"] ]}
});
</script>

<!-- This is what works with Quarto -->
<script>
  MathJax = {
    tex: {
      tags: 'ams'  // should be 'ams', 'none', or 'all'
    }
  };
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Yes! You can do that in <code>mgcv</code>!</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contributing.html"> 
<span class="menu-text">Contributing material</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-articles" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Articles</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-articles">    
        <li>
    <a class="dropdown-item" href="../articles/gamvar.html">
 <span class="dropdown-text">GAM variance estimation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/prediction_intervals.html">
 <span class="dropdown-text">Prediction intervals</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/poisson_processes.html">
 <span class="dropdown-text">Poisson processes in <code>mgcv</code></span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/ncv.html">
 <span class="dropdown-text">Neighbourhood cross-validation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../articles/ncv_timeseries.html">
 <span class="dropdown-text">Neighbourhood cross-validation for time series</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#an-overused-example-motorcycle-crash-data" id="toc-an-overused-example-motorcycle-crash-data" class="nav-link active" data-scroll-target="#an-overused-example-motorcycle-crash-data">An overused example: motorcycle crash data</a></li>
  <li><a href="#adaptive-smoothing-tools-we-need" id="toc-adaptive-smoothing-tools-we-need" class="nav-link" data-scroll-target="#adaptive-smoothing-tools-we-need">Adaptive smoothing: tools we need</a>
  <ul class="collapse">
  <li><a href="#multiple-penalties" id="toc-multiple-penalties" class="nav-link" data-scroll-target="#multiple-penalties">Multiple penalties</a></li>
  <li><a href="#p-splines" id="toc-p-splines" class="nav-link" data-scroll-target="#p-splines">P-splines</a></li>
  <li><a href="#b-spline-basis" id="toc-b-spline-basis" class="nav-link" data-scroll-target="#b-spline-basis">B-spline basis</a></li>
  <li><a href="#p-spline-difference-penalties" id="toc-p-spline-difference-penalties" class="nav-link" data-scroll-target="#p-spline-difference-penalties">P-spline difference penalties</a></li>
  </ul></li>
  <li><a href="#back-to-adaptive-smoothing" id="toc-back-to-adaptive-smoothing" class="nav-link" data-scroll-target="#back-to-adaptive-smoothing">Back to adaptive smoothing…</a></li>
  <li><a href="#adaptive-smoothing-in-practice" id="toc-adaptive-smoothing-in-practice" class="nav-link" data-scroll-target="#adaptive-smoothing-in-practice">Adaptive smoothing in practice</a>
  <ul class="collapse">
  <li><a href="#more-options" id="toc-more-options" class="nav-link" data-scroll-target="#more-options">More options</a></li>
  </ul></li>
  <li><a href="#other-approaches-and-further-reading" id="toc-other-approaches-and-further-reading" class="nav-link" data-scroll-target="#other-approaches-and-further-reading">Other approaches and further reading</a></li>
  <li><a href="#thanks" id="toc-thanks" class="nav-link" data-scroll-target="#thanks">Thanks</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Adaptive smoothing in <code>mgcv</code></h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David L Miller </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>When we set-up a smoother in a GAM, we have a penalty that is of the following matrix form: <span class="math display">\[\begin{equation}
\lambda \boldsymbol{\beta}^\intercal \mathbf{S} \boldsymbol{\beta}.
\label{pen}
\end{equation}\]</span> where we have the fixed elements (usually integrals of derivatives of the basis functions) in <span class="math inline">\(\mathbf{S}\)</span> and the smoothers’ coefficients in <span class="math inline">\(\boldsymbol{\beta}\)</span>. is the <em>smoothing parameter</em> which we also estimate and controls the influence of the penalty on the fit (usually, we have the above expression substracted from the restricted or marginal likelihood for REML or ML).</p>
<p>The smoothing parameter, <span class="math inline">\(\lambda\)</span>, tells us about how <em>wiggly</em> to make our functions. A <span class="math inline">\(\lambda\)</span> of 0 will mean that the whole penalty term is evaluated as zero, meaning the smother will overfit to the data. Letting <span class="math inline">\(\lambda\)</span> get larger and larger, we end up with the penalty dominating the fit. In that case we retrieve only the nullspace terms: those bits of the basis which don’t have derivatives (so aren’t affected by the penalty).</p>
<p>This all works well in general, up to a point. What happens when the amount of smoothing we need changes with the covariate? In other words: what if we need the amount of smoothing to be adaptive?</p>
<p>Most of this is based off Sections 5.33 and 5.3.5 of <span class="citation" data-cites="wood_generalized_2017a">SN Wood (<a href="#ref-wood_generalized_2017a" role="doc-biblioref">2017</a>)</span> as well as the <a href="https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/smooth.construct.ad.smooth.spec.html"><code>?smooth.construct.ad.smooth.spec</code></a> manual page, with a bit more explanation. See the last section for links to other approaches.</p>
<section id="an-overused-example-motorcycle-crash-data" class="level1">
<h1>An overused example: motorcycle crash data</h1>
<p>Every expanation of adaptive smoothing uses the same tired example. This article is no different. The “simulated motorcycle crash data” found in <code>MASS::mcycle</code> seems to originate (in the statistics literature) in <span class="citation" data-cites="silverman_aspects_1985">Silverman (<a href="#ref-silverman_aspects_1985" role="doc-biblioref">1985</a>)</span> (which is a great paper!). The data originally come from a rather grim experiment <span class="citation" data-cites="schmidt1981biomechanical">(<a href="#ref-schmidt1981biomechanical" role="doc-biblioref">Schmidt <em>et al.</em>, 1981</a>)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> where cadavers were given helments and hurled at walls to see what happens on impact. For our purposes, we are interested in the accelaration change recorded on sensors on the helmet.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(mcycle) <span class="sc">+</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">x=</span>times, <span class="at">y=</span>accel)) <span class="sc">+</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x=</span><span class="st">"Time (ms)"</span>, <span class="at">y=</span><span class="st">"Acceleration (g)"</span>) <span class="sc">+</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="adaptive_smoothing_files/figure-html/mcycle-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>From a smoothing perspective, the data are interesting because there are clearly different variances at different times. We see a very flat start up to the impact, followed by rapid decelleration, then rebound to acceleration, then movement back to the zero line again (but with much more spread).</p>
<p>We can fit the data using a regular smoother and see what happens:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(mgcv)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: nlme</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>This is mgcv 1.9-3. For overview type 'help("mgcv-package")'.</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> <span class="fu">gam</span>(accel <span class="sc">~</span> <span class="fu">s</span>(times), <span class="at">data=</span>mcycle)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>plot_mpreds <span class="ot">&lt;-</span> <span class="cf">function</span>(model){</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  xx <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">times =</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">60</span>, <span class="at">length.out=</span><span class="dv">400</span>))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  pp <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, <span class="at">newdata=</span>xx, <span class="at">se=</span><span class="cn">TRUE</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  xx<span class="sc">$</span>accel <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(pp<span class="sc">$</span>fit)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  xx<span class="sc">$</span>upper <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(pp<span class="sc">$</span>fit <span class="sc">+</span> <span class="fl">1.96</span><span class="sc">*</span>pp<span class="sc">$</span>se.fit)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  xx<span class="sc">$</span>lower <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(pp<span class="sc">$</span>fit <span class="sc">-</span> <span class="fl">1.96</span><span class="sc">*</span>pp<span class="sc">$</span>se.fit)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">x=</span>times, <span class="at">y=</span>accel), <span class="at">data=</span>mcycle) <span class="sc">+</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_ribbon</span>(<span class="fu">aes</span>(<span class="at">x=</span>times, <span class="at">ymin=</span>lower, <span class="at">ymax=</span>upper),</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                <span class="at">colour=</span><span class="st">"grey60"</span>, <span class="at">alpha=</span><span class="fl">0.5</span>,</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                <span class="at">data=</span>xx) <span class="sc">+</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x=</span>times, <span class="at">y=</span>accel), <span class="at">data=</span>xx) <span class="sc">+</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">x=</span><span class="st">"Time (ms)"</span>, <span class="at">y=</span><span class="st">"Acceleration (g)"</span>) <span class="sc">+</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>()</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_mpreds</span>(b)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="adaptive_smoothing_files/figure-html/badfit-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>What we see in this simple fit is some annoying misbehaviour in either extreme of the data. Why is the smoother decreasing at from zero, only to increase again before impact? At the other end, why do we see such wiggly behaviour followed by increase? These features aren’t supported by the data.</p>
<p>This is really down to the smoothing parameter being optimized for the bulk of the data, which is quite wiggly (and where we fit well). We are stuck with the <span class="math inline">\(\lambda\)</span> which does best “on average”, so our model sucks at either end of the data.</p>
<p>But, what if we could make <span class="math inline">\(\lambda\)</span> a function of the time covariate?</p>
</section>
<section id="adaptive-smoothing-tools-we-need" class="level1">
<h1>Adaptive smoothing: tools we need</h1>
<p>Let’s imagine a very simple case, where we have data where the first half is very wiggly, then the second half is less wiggly. We would then want a separate smoothing parameter for the first half of the data (which was smaller, giving more wiggles) and another for the second half (larger, giving fewer wiggles). The first smoothing parameter would just apply to the first half of the basis functions and the latter to the second half (assuming we have a nice evenly-spaced basis; more on that in a moment).</p>
<p>We might want to go beyond that and move to multiple <span class="math inline">\(\lambda\)</span>s over the range of the data. We need some tools to build such a thing.</p>
<section id="multiple-penalties" class="level2">
<h2 class="anchored" data-anchor-id="multiple-penalties">Multiple penalties</h2>
<p>First we need to build a penalty for such a term. We can extend <span class="math inline">\(\eqref{pen}\)</span> to the case where we have multiple penalties for a single term. In which case we write <span class="math display">\[\begin{equation}
  \sum_j \lambda_j \boldsymbol{\beta}^\intercal \mathbf{S}_j \boldsymbol{\beta},
\label{multpen}
\end{equation}\]</span> where we have split the penalty matrices and smoothing parameters and indexed them by <span class="math inline">\(j\)</span>. This idea should be fairly familiar as it’s how we create the total penalty for models with multiple terms. Just in this case, we’re using it for a single term.</p>
</section>
<section id="p-splines" class="level2">
<h2 class="anchored" data-anchor-id="p-splines">P-splines</h2>
<p>We need a basis to build our terms. For efficiency and interpretability purposes, <code>mgcv</code> uses P-splines <span class="citation" data-cites="eilers_flexible_1996">(<a href="#ref-eilers_flexible_1996" role="doc-biblioref">Eilers and Marx, 1996</a>)</span> to construct adaptive smoothers. Since they’re a bit different from other splines, let’s just review them for a moment.</p>
<p>“P-splines” in the sense used in <code>mgcv</code> are Marx and Eiler’s “B-splines”: they are a B-spline basis with a “difference” penalty (rather than an integral penalty). This makes things much faster for computation.</p>
</section>
<section id="b-spline-basis" class="level2">
<h2 class="anchored" data-anchor-id="b-spline-basis">B-spline basis</h2>
<p>The B-spline basis is an interesting and useful one. We setup the basis functions by recursion, so an order <span class="math inline">\(m+1\)</span> basis function is to multiply some fixed thing (which we’ll avoid writing-out here because I don’t think it adds much to the explanation) by the <span class="math inline">\(m^\text{th}\)</span> order basis function. The <span class="math inline">\(-1^\text{th}\)</span> order basis functions are just 1 inside a range and 0 outside.</p>
<p>We place the B-spline basis at <em>knots</em> (the knot is the centre of the basis function) and a basis function of order <span class="math inline">\(m+1\)</span> (where <span class="math inline">\(m=2\)</span> is a cubic spline, for boring definitional reasons) will be non-zero over the <span class="math inline">\(m+3\)</span> adjacent knots. This, along with the regular placement of knots (more on that in a moment) means that B-splines are a <em>local basis</em> (that their effects are felt only in the vicinity of their knot). This makes them easy to interpret (compared to, say, thin plate splines). <a href="#fig-bsbasis" class="quarto-xref">Figure&nbsp;1</a> shows some cubic B-spline basis functions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># taken from Wood (2017)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>bspline <span class="ot">&lt;-</span> <span class="cf">function</span>(x,k,i,<span class="at">m=</span><span class="dv">2</span>){</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># evaluate ith b-spline basis function of order m at the values</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># in x, given knot locations in k</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (m<span class="sc">==-</span><span class="dv">1</span>){ <span class="co"># base of recursion</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    res <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(x<span class="sc">&lt;</span>k[i<span class="sc">+</span><span class="dv">1</span>]<span class="sc">&amp;</span>x<span class="sc">&gt;=</span>k[i])</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  }<span class="cf">else</span>{</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># construct from call to lower order basis</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    z0 <span class="ot">&lt;-</span> (x<span class="sc">-</span>k[i])<span class="sc">/</span>(k[i<span class="sc">+</span>m<span class="sc">+</span><span class="dv">1</span>]<span class="sc">-</span>k[i])</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    z1 <span class="ot">&lt;-</span> (k[i<span class="sc">+</span>m<span class="sc">+</span><span class="dv">2</span>]<span class="sc">-</span>x)<span class="sc">/</span>(k[i<span class="sc">+</span>m<span class="sc">+</span><span class="dv">2</span>]<span class="sc">-</span>k[i<span class="sc">+</span><span class="dv">1</span>])</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    res <span class="ot">&lt;-</span> z0<span class="sc">*</span><span class="fu">bspline</span>(x,k,i,m<span class="dv">-1</span>)<span class="sc">+</span> z1<span class="sc">*</span><span class="fu">bspline</span>(x,k,i<span class="sc">+</span><span class="dv">1</span>,m<span class="dv">-1</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  res</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># knot locations</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>nk <span class="ot">&lt;-</span> <span class="dv">16</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>knts <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>, <span class="at">length.out=</span>nk)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co"># grid for evaluation</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>xx <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length.out=</span><span class="dv">200</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.7</span>), <span class="at">type=</span><span class="st">"n"</span>,</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="st">"x"</span>, <span class="at">ylab=</span><span class="st">"b(x)"</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nk){</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lines</span>(xx, <span class="fu">bspline</span>(xx, knts, i, <span class="dv">2</span>), <span class="at">lty=</span><span class="dv">2</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-bsbasis" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bsbasis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="adaptive_smoothing_files/figure-html/fig-bsbasis-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bsbasis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: A B-spline basis.
</figcaption>
</figure>
</div>
</div>
</div>
<p>More in-depth information on B-splines can be found in classic texts like <span class="citation" data-cites="deboor_practical_1978">DeBoor (<a href="#ref-deboor_practical_1978" role="doc-biblioref">1978</a>)</span>. For more on their implementation in <code>mgcv</code> you can see Section 5.3.3 of <span class="citation" data-cites="wood_generalized_2017a">SN Wood (<a href="#ref-wood_generalized_2017a" role="doc-biblioref">2017</a>)</span> and <span class="citation" data-cites="wood_psplines_2017">Simon N Wood (<a href="#ref-wood_psplines_2017" role="doc-biblioref">2017</a>)</span>.</p>
</section>
<section id="p-spline-difference-penalties" class="level2">
<h2 class="anchored" data-anchor-id="p-spline-difference-penalties">P-spline difference penalties</h2>
<p>Now we could use the regular formulation to create a penalty for these P-splines: we can take derivatives and integrate over the range of the covariate. Instead, we can do something a bit faster and more efficient. This speed an efficiency comes at a cost of accuracy, but this often doesn’t matter much.</p>
<p>Rather than the derivative-based penalties we usually use for splines, we’re going to use a <em>difference-based penalty</em>. Where the differences are between the neighbouring <span class="math inline">\(\beta\)</span>s in the model.</p>
<p>The first order P-spline penalty is <span class="math display">\[\begin{equation}
        \mathcal{P}_1 = \sum_{k=1}^K (\beta_{k+1}-\beta_k)^2
\label{bs-firstorder-pen}
\end{equation}\]</span> where we have <span class="math inline">\(K\)</span> basis functions (or knots if you think about the world that way). Note we still square the difference, just as we do in a derivative-based penalty.</p>
<p>We can re-write <span class="math inline">\(\eqref{bs-firstorder-pen}\)</span> in matrix-form by writing a matrix <span class="math inline">\(\mathbf{P}\)</span> such that: <span class="math display">\[
\mathbf{P} = \pmatrix{-1 &amp;  1 &amp;  0 &amp;  0 &amp; 0 &amp; \cdots\\
                       0 &amp; -1 &amp;  1 &amp;  0 &amp; 0 &amp; \cdots\\
                       0 &amp;  0 &amp; -1 &amp;  1 &amp; 0 &amp; \cdots\\
                         &amp;    &amp;    &amp; \ddots &amp; \ddots &amp; &amp; }
\]</span> which just reflects the <span class="math inline">\(\beta_{k+1}-\beta_k\)</span> term, taking the previous value away from the current one. Indeed, <span class="math display">\[
P\boldsymbol{\beta} = \pmatrix{\beta_2-\beta_1\\
                               \beta_3-\beta_2\\
                               \beta_4-\beta_3\\
                               \vdots},
\]</span> and in order to get our penalty <span class="math inline">\(\mathcal{P}_1\)</span>, we just need to take the product <span class="math inline">\(\mathbf{P}^\intercal P\)</span> <span class="math display">\[
\mathcal{P}_1 = \boldsymbol{\beta}^\intercal \mathbf{P}^\intercal \mathbf{P}\boldsymbol{\beta} = \sum_{k=1}^K (\beta_{k+1}-\beta_k)^2.
\]</span></p>
<p>Our 2nd order penalty is <span class="math display">\[\begin{equation}
        \mathcal{P}_2 = \sum_{k=1}^K (\beta_{k-1} -2\beta_k +\beta{i+1})^2
\label{bs-secondorder-pen}
\end{equation}\]</span> which gives us the following <span class="math inline">\(\mathbf{P}\)</span> matrix: <span class="math display">\[
\mathbf{P} = \pmatrix{1 &amp; -2 &amp;  1 &amp;  0 &amp; 0 &amp; \cdots\\
             0 &amp; 1  &amp; -2 &amp;  1 &amp; 0 &amp; \cdots\\
             0 &amp; 0  &amp;  1 &amp; -2 &amp; 1 &amp; \cdots\\
               &amp;    &amp;    &amp;  \ddots  &amp; \ddots &amp;\ddots  &amp; }.
\]</span></p>
<p>Now, these matrices are <em>extremely</em> fast to compute in R, because we just need to use the <code>diff</code> function on a diagonal matrix:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(P1 <span class="ot">&lt;-</span> <span class="fu">diff</span>(<span class="fu">diag</span>(<span class="dv">10</span>), <span class="at">differences=</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]   -1    1    0    0    0    0    0    0    0     0
 [2,]    0   -1    1    0    0    0    0    0    0     0
 [3,]    0    0   -1    1    0    0    0    0    0     0
 [4,]    0    0    0   -1    1    0    0    0    0     0
 [5,]    0    0    0    0   -1    1    0    0    0     0
 [6,]    0    0    0    0    0   -1    1    0    0     0
 [7,]    0    0    0    0    0    0   -1    1    0     0
 [8,]    0    0    0    0    0    0    0   -1    1     0
 [9,]    0    0    0    0    0    0    0    0   -1     1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(P2 <span class="ot">&lt;-</span> <span class="fu">diff</span>(<span class="fu">diag</span>(<span class="dv">10</span>), <span class="at">differences=</span><span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    1   -2    1    0    0    0    0    0    0     0
[2,]    0    1   -2    1    0    0    0    0    0     0
[3,]    0    0    1   -2    1    0    0    0    0     0
[4,]    0    0    0    1   -2    1    0    0    0     0
[5,]    0    0    0    0    1   -2    1    0    0     0
[6,]    0    0    0    0    0    1   -2    1    0     0
[7,]    0    0    0    0    0    0    1   -2    1     0
[8,]    0    0    0    0    0    0    0    1   -2     1</code></pre>
</div>
</div>
<p>No differentiation, no integration. Lovely.</p>
</section>
</section>
<section id="back-to-adaptive-smoothing" class="level1">
<h1>Back to adaptive smoothing…</h1>
<p>Now we have our bits to construct the adaptive smoother, we can actually do that.</p>
<p>We can first think about decomposing the penalty as if it were a B-spline basis, so we have <span class="math inline">\(\mathbf{S} = \mathbf{P}^\intercal\mathbf{P}\)</span>. To weight this we could make a diagonal matrix with the weighting (or penalty) for each basis function in each element. Let’s call that <span class="math inline">\(\text{diag}(\boldsymbol{\lambda})\)</span>. We would then write: <span class="math display">\[
\mathbf{S} = \mathbf{P}^\intercal\mathbf{P} = \mathbf{P}^\intercal \text{diag}(\boldsymbol{\lambda}) \mathbf{P}
\]</span> we can see that this recovers the regular single penalty when we set <span class="math inline">\(\mathbf{\lambda}\)</span> to a single value, so we would have <span class="math inline">\(\text{diag}(\boldsymbol{\lambda})=\lambda \mathbf{I}\)</span>, so: <span class="math display">\[
\mathbf{P}^\intercal \text{diag}(\boldsymbol{\lambda}) \mathbf{P} = \mathbf{P}^\intercal\lambda \mathbf{I}\mathbf{P} =\lambda  \mathbf{P}^\intercal\mathbf{I}\mathbf{P} =\lambda  \mathbf{P}^\intercal\mathbf{P}.
\]</span></p>
<p>Our aim is to make the smoothing parameter into a function that is smooth over the covariate. Fortunately we already have a tool for making smooth functions: splines. So via basis expansion: <span class="math display">\[\begin{equation}
        \boldsymbol{\lambda} = \mathbf{B}\boldsymbol{\gamma}
\end{equation}\]</span> where <span class="math inline">\(\mathbf{B}\)</span> is the design matrix for the smoothing parameter (made of, you guess it, B-splines) and <span class="math inline">\(\boldsymbol{\gamma}\)</span> are the associated parameters. We’ll call this our <em>penalty basis</em>. Let the number of basis functions/knots used for <span class="math inline">\(\boldsymbol{\lambda}\)</span> be <span class="math inline">\(k_\lambda\)</span> (hence the number of columns in <span class="math inline">\(\mathbf{B}\)</span>).</p>
<p>By the local property of the B-spline basis, we know that the columns of <span class="math inline">\(\mathbf{B}\)</span> will have non-zero entries around a given knot, then be zero elsewhere (assuming that <span class="math inline">\(\mathbf{B}\)</span> is evaluated over a sequence of evenly spaced points along the covariate).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># knot locations</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>nk <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>nd <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>knts <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="fl">0.5</span>, <span class="fl">1.5</span>, <span class="at">length.out=</span>nk)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># grid for evaluation</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>xx <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length.out=</span>nd)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">#bspline &lt;- function(x,k,i,m=2){</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>XX <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">xx =</span> xx,</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                  <span class="at">knts =</span> knts[<span class="dv">2</span><span class="sc">:</span><span class="dv">6</span>])</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>XX<span class="sc">$</span>p <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">lapply</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">6</span>, bspline, <span class="at">x=</span>xx, <span class="at">k=</span>knts, <span class="at">m=</span><span class="dv">2</span>))</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(XX) <span class="sc">+</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>(<span class="fu">aes</span>(<span class="at">x=</span>knts, <span class="at">y=</span>xx, <span class="at">fill=</span>p)) <span class="sc">+</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_y_reverse</span>() <span class="sc">+</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_fill_gradient</span>(<span class="at">low=</span><span class="st">"#fff"</span>, <span class="at">high=</span><span class="st">"#ff0000"</span>) <span class="sc">+</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_equal</span>() <span class="sc">+</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_void</span>() <span class="sc">+</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-bsbasis-mat" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bsbasis-mat-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="adaptive_smoothing_files/figure-html/fig-bsbasis-mat-1.png" class="img-fluid figure-img" width="672">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bsbasis-mat-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Visualisation of a B-spline basis design matrix.
</figcaption>
</figure>
</div>
</div>
</div>
<p>We can show that <span class="math inline">\(\text{diag}(\boldsymbol{\lambda}) = \text{diag}(\mathbf{B}\boldsymbol{\gamma}) = \sum_j \boldsymbol{\gamma}_j \text{diag}(\mathbf{B}_{.j})\)</span> with basic linear algebra.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> So we can now write: <span class="math display">\[\begin{equation*}
\boldsymbol{\beta}^\intercal \mathbf{P}^\intercal \text{diag}(\boldsymbol{\lambda}) \mathbf{P} \boldsymbol{\beta} = \boldsymbol{\beta}^\intercal \mathbf{P}^\intercal \text{diag}(\mathbf{B}\boldsymbol{\gamma}) \mathbf{P} \boldsymbol{\beta} = \sum_j \boldsymbol{\gamma}_j \boldsymbol{\beta}^\intercal \mathbf{P}^\intercal \text{diag}(\mathbf{B}_{.j}) \mathbf{P} \boldsymbol{\beta}
\end{equation*}\]</span> Finally, let <span class="math inline">\(\mathbf{S}_j = \mathbf{P}^\intercal \text{diag}(\mathbf{B}_{.j}) \mathbf{P}\)</span>, we have that our penalty is: <span class="math display">\[
\sum_j \gamma_j \boldsymbol{\beta}^\intercal \mathbf{S}_j \boldsymbol{\beta},
\]</span> which is exactly the same form as <span class="math inline">\(\eqref{multpen}\)</span> but with the smoothing parameters <span class="math inline">\(\gamma_j\)</span> being the coefficients for our penalty basis.</p>
<p><code>mgcv</code> can only really<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> use one kind of penalty and that’s the quadratic form we have in <span class="math inline">\(\eqref{multpen}\)</span>. So, its’ rather nice that we can work our adaptive penalty into this form. That means we can use all the usual tools in <code>mgcv</code> and not worry about extra fitting stuff.</p>
<p>Note that there is no penalty attached to <span class="math inline">\(\boldsymbol{\lambda}\)</span>’s parameters <span class="math inline">\(\boldsymbol{\gamma}\)</span> themselves we just have a continuous function, not any control on how wiggly it can be (though the size of <span class="math inline">\(k_\lambda\)</span> will constrain this to some extent).</p>
</section>
<section id="adaptive-smoothing-in-practice" class="level1">
<h1>Adaptive smoothing in practice</h1>
<p>Okay, with the maths out of the way, we can go back to our “motorcycle”<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> dataset.</p>
<p>Given the above hoops, the setup of adaptive smooths in <code>mgcv</code> is very simple. We just need to set the basis to <code>"ad"</code> and we’re good to go:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>b_ad <span class="ot">&lt;-</span> <span class="fu">gam</span>(accel <span class="sc">~</span> <span class="fu">s</span>(times, <span class="at">bs=</span><span class="st">"ad"</span>), <span class="at">data=</span>mcycle)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>(<span class="fu">plot_mpreds</span>(b) <span class="sc">+</span> <span class="fu">ggtitle</span>(<span class="st">"Thin-plate regression splines"</span>)) <span class="sc">+</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>(<span class="fu">plot_mpreds</span>(b_ad) <span class="sc">+</span> <span class="fu">ggtitle</span>(<span class="st">"Adaptive smoothing via P-splines"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div id="fig-tprsadcomp" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-tprsadcomp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="adaptive_smoothing_files/figure-html/fig-tprsadcomp-1.png" class="img-fluid figure-img" width="960">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-tprsadcomp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Comparison of thin-plate splines (left) and adaptive smoothing (right) for the motorcycle dataset.
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-tprsadcomp" class="quarto-xref">Figure&nbsp;3</a> shows a comparison of adaptive smoothing and our initial try with thin-plate regression splines. Not only does the adaptive smoother capture the flatness in either extreme of the data, we also have narrower confidence intervals.</p>
<section id="more-options" class="level2">
<h2 class="anchored" data-anchor-id="more-options">More options</h2>
<p>There are a few things that we can change in the adaptive smoothing specification.</p>
<ul>
<li><em>Basis</em>: we can use a fairly restricted set of basis functions can be used for the smoother (P-splines <code>"ps"</code>, cyclic P-splines <code>"cp"</code>, cyclic cubic splines <code>"cc"</code> or cubic splines <code>"cr"</code>), the penalty basis can only be a P-spline or cyclic P-spline. These are set via the <code>xt=list(...)</code> option to <code>s()</code>, specifically the <code>$bs</code> element, as a character <code>vector</code> (e.g., <code>xt=list(bs=c("cp", "cp"))</code> for cyclic smoother and penalty).</li>
<li><em>Penalty basis size</em>: this is controlled by the <code>m</code> argument to <code>s()</code>. Note that this can’t be too big, as the model will get slow very quickly. It’s best to start small and increase slowly. Due to the local nature of B-splines, we are estimating the <span class="math inline">\(\gamma_j\)</span> parameters from a much reduced subset of data. From <a href="https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/smooth.construct.ad.smooth.spec.html">the help file</a> “setting <code>m=10</code> for a univariate smooth of 200 data is rather like estimating 10 smoothing parameters, each from a data series of length 20.”</li>
</ul>
<p>Note that adaptive smoothers can’t be used with <code>gamm</code> or as marginals in tensor product smooths. We can make 2-dimensional version of these smoothers (and fit that in <code>mgcv</code>) for cases where we have changing smoothness in space.</p>
</section>
</section>
<section id="other-approaches-and-further-reading" class="level1">
<h1>Other approaches and further reading</h1>
<p>This approach is neat because it fits into the general <code>mgcv</code> scheme of fitting GAMs. That means we get to use all the other tools that are in <code>mgcv</code>. That said, lots of people have thought about this problem.</p>
<p>An early approach to this problem is suggested in <span class="citation" data-cites="ruppert_spatiallyadaptive_2000">Ruppert and Carroll (<a href="#ref-ruppert_spatiallyadaptive_2000" role="doc-biblioref">2000</a>)</span>. Their approach is similar in some ways, but doesn’t use the nice properties of P-splines (for example they model the penalty basis on the <span class="math inline">\(\log_e\)</span> scale, which seems weird given the B-spline basis functions are positive). It feels a bit less elegant that what I describe above.@baladandayuthapani_spatially_2005 and <span class="citation" data-cites="crainiceanu_spatially_2007">Crainiceanu <em>et al.</em> (<a href="#ref-crainiceanu_spatially_2007" role="doc-biblioref">2007</a>)</span> build on this approach further. <span class="citation" data-cites="lang_bayesian_2004">(<a href="#ref-lang_bayesian_2004" role="doc-biblioref"><strong>lang_bayesian_2004?</strong></a>)</span> and <span class="citation" data-cites="jullion_robust_2007">Jullion and Lambert (<a href="#ref-jullion_robust_2007" role="doc-biblioref">2007</a>)</span> provide fully Bayesian approaches but again don’t quite get to the elegance of the above. <span class="citation" data-cites="yue_bayesian_2014">Yue <em>et al.</em> (<a href="#ref-yue_bayesian_2014" role="doc-biblioref">2014</a>)</span> propose a much more fancy version, again Bayesian, applying the SPDE approach in INLA. I need to think about that last paper more, but the approach involves things like formulating stochastic differential equations and words like “Galerkin approximation” so it will have to wait until a future date.</p>
</section>
<section id="thanks" class="level1">
<h1>Thanks</h1>
<p>Time to think about this was partly funded by <a href="https://www.bioss.ac.uk">BioSS</a> “topic group”: “what we talk about when we talk about random effects”. Thanks also to John Addy for extremely useful discussions.</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-crainiceanu_spatially_2007" class="csl-entry" role="listitem">
Crainiceanu, C. M., Ruppert, D., Carroll, R. J., et al. (2007) Spatially <span>Adaptive Bayesian Penalized Splines With Heteroscedastic Errors</span>. <em>Journal of Computational and Graphical Statistics</em>, <strong>16</strong>, 265–288. DOI: <a href="https://doi.org/10.1198/106186007X208768">10.1198/106186007X208768</a>.
</div>
<div id="ref-deboor_practical_1978" class="csl-entry" role="listitem">
DeBoor, C. (1978) <em>A <span>Practical Guide</span> to <span>Splines</span></em>. Springer New York.
</div>
<div id="ref-eilers_flexible_1996" class="csl-entry" role="listitem">
Eilers, P. H. and Marx, B. D. (1996) Flexible smoothing with <span class="nocase">B-splines</span> and penalties. <em>Statistical science</em>, <strong>11</strong>, 89–102.
</div>
<div id="ref-jullion_robust_2007" class="csl-entry" role="listitem">
Jullion, A. and Lambert, P. (2007) Robust specification of the roughness penalty prior distribution in spatially adaptive <span class="nocase">Bayesian P-splines</span> models. <em>Computational Statistics &amp; Data Analysis</em>, <strong>51</strong>, 2542–2558. DOI: <a href="https://doi.org/10.1016/j.csda.2006.09.027">10.1016/j.csda.2006.09.027</a>.
</div>
<div id="ref-ruppert_spatiallyadaptive_2000" class="csl-entry" role="listitem">
Ruppert, D. and Carroll, R. J. (2000) Spatially-adaptive <span>Penalties</span> for <span>Spline Fitting</span>. <em>Australian &amp; New Zealand Journal of Statistics</em>, <strong>42</strong>, 205–223. DOI: <a href="https://doi.org/10.1111/1467-842X.00119">10.1111/1467-842X.00119</a>.
</div>
<div id="ref-schmidt1981biomechanical" class="csl-entry" role="listitem">
Schmidt, G., Mattern, R. and Schüler, F. (1981) Biomechanical investigation to determine physical and traumatological differentiation criteria for the maximum load capacity of head and vertebral column with and without protective helmet under the effects of impact. <em>EEC Research Program on Biomechanics of Impacts, Final report, Phase III, Project G</em>, <strong>5</strong>.
</div>
<div id="ref-silverman_aspects_1985" class="csl-entry" role="listitem">
Silverman, B. W. (1985) Some <span>Aspects</span> of the <span>Spline Smoothing Approach</span> to <span>Non-Parametric Regression Curve Fitting</span>. <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <strong>47</strong>, 1–52.
</div>
<div id="ref-wood_generalized_2017a" class="csl-entry" role="listitem">
Wood, S. N. (2017) <em>Generalized <span>Additive Models</span>. <span>An Introduction</span> with <span>R</span></em>. 2nd ed. Texts in <span>Statistical Science</span>. CRC Press.
</div>
<div id="ref-wood_psplines_2017" class="csl-entry" role="listitem">
Wood, Simon N. (2017) P-splines with derivative based penalties and tensor product smoothing of unevenly distributed data. <em>Statistics and Computing</em>, <strong>27</strong>, 985–989. DOI: <a href="https://doi.org/w">w</a>.
</div>
<div id="ref-yue_bayesian_2014" class="csl-entry" role="listitem">
Yue, Y. R., Simpson, D., Lindgren, F., et al. (2014) Bayesian <span>Adaptive Smoothing Splines Using Stochastic Differential Equations</span>. <em>Bayesian Analysis</em>, <strong>9</strong>, 397–424. DOI: <a href="https://doi.org/10.1214/13-BA866">10.1214/13-BA866</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Though this report doesn’t appear to be findable, one can find a rather gruesome NATO conference proceedings from around the same time by the same authors which appears to demonstrate the same ideas <a href="https://apps.dtic.mil/sti/tr/pdf/ADA123814.pdf#page=58">here</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The first element of the column vector <span class="math inline">\(\mathbf{B}\boldsymbol{\gamma}\)</span> is <span class="math inline">\(\mathbf{B}_{11}\lambda_1 +\mathbf{B}_{12}\lambda_2 + \ldots = \sum_j \lambda_j \mathbf{B}_{1j}\)</span> and so on for the second row etc.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>There is a more complicated way but I’ll save that for another article.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Read “traumatic head injury”<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/calgary\.converged\.yt");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>